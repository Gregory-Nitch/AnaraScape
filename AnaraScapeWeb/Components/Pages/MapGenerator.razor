@page "/map-generator"

@using AnaraScapeWeb.Components.Layout
@using DataAccess
@using DataAccess.Models
@using MapDesignLibrary
@using Library59.ImageProcessing
@using SkiaSharp


@implements IDisposable

@inject DungeonTileCache TileCache
@inject IJSRuntime JS
@inject ICrud crud
@inject NavigationManager NavManager

@rendermode InteractiveServer

@layout Layout.GenLayout

<PageTitle>Map Generator</PageTitle>

<ToolBar OnGenerate="GenNewDesign" OnDownload="RequestDownload" OnGenError="ShowError" ToolBarErrMsg="@GenErrMsg"/>
<ProcessingOverlay />

<div id="mapWrapper" oncontextmenu="event.preventDefault();">

    <div id="mapOverlay">
        @if (MapDesign != null)
        {
            @for (int i = 0, sectionId = 1; i < MapDesign.DisplayMatrix.Count(); i++)
            {
                string rowId = $"tileRow{i + 1}";
                <div class="mapRow" id=@rowId>
                    @for (int j = 0; j < MapDesign.DisplayMatrix[0].Count(); j++)
                    {
                        if (MapDesign.TileMatrix[i][j].Count() == 1)
                        {
                            <div class="reqCol" id=@sectionId></div>
                        }
                        else
                        {
                            <div class="column" id=@sectionId></div>
                        }
                        sectionId++;
                    }
                </div>
            }
        }
        else
        {
            GenBaseDesign();
        }
    </div>

    <canvas id="mapCanvas"></canvas>

</div>


@code {

    private DotNetObjectReference<MapGenerator>? BCompRef;
    private MapDesigner? MapDesigner;
    private MapDesign? MapDesign;
    private readonly int BASE_TILE_SIZE = 512;
    private bool shouldRender;
    private readonly string GenErrMsg = "Oops! There was an error generating a design, we'll look into it! Try again?";
    private readonly string DownloadErrMsg = "Oops! There was an error merging that map, we'll look into it! Try again?";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            BCompRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("DotNetRef.getBCompReference", BCompRef);
        }
        if (MapDesign != null)
        {
            await JS.InvokeVoidAsync("DotNetRef.requestMapDesign");
        }
    }

    // Need to control rendering for request download events
    protected override bool ShouldRender() => shouldRender;

    private void GenBaseDesign()
    {
        shouldRender = true;

        try
        {
            MapDesigner = new(3, 3, "fort", "top", false, TileCache.DBTiles);
            MapDesign = MapDesigner.Generate();
        }
        catch (MapDesignException ex)
        {
            crud.InsertLogEvent(new LogEvent(DateTime.Now, LogLevel.Error, ex.Message));
            ShowError(GenErrMsg);
        }

        StateHasChanged();
    }

    private void GenNewDesign(MapDesigner newDesigner)
    {
        shouldRender = true;
        MapDesigner = newDesigner;

        try
        {
            MapDesign = MapDesigner.Generate();
        }
        catch (MapDesignException ex)
        {
            crud.InsertLogEvent(new LogEvent(DateTime.Now, LogLevel.Error, ex.Message));
            ShowError(GenErrMsg);
        }

        StateHasChanged();
    }

    private async void RequestDownload()
    {
        shouldRender = false;
        await JS.InvokeVoidAsync("DotNetRef.requestMapDownload");
    }

    public void Dispose()
    {
        BCompRef?.Dispose();
    }

    [JSInvokable]
    public Task<MapDesign> SendDesignAsync()
    {
        return Task.FromResult(MapDesign!);
    }

    /// <summary>
    /// Should only be hit if the browser fails to merge tile images (too large for html canvas).
    /// </summary>
    /// <param name="displayMatFromJS">Id matrix retrieved from client</param>
    /// <returns>byte array to client</returns>
    [JSInvokable]
    public Task<byte[]> SendImageBlobAsync(int[][] displayMatFromJS)
    {
        crud.InsertLogEvent(new LogEvent(DateTime.Now, LogLevel.Information, "Client requested image merging"));

        // Place image paths in 2d list for processing
        List<List<string>> imagePathMatrix = [];
        foreach (int[] row in displayMatFromJS)
        {
            List<string> imgRow = [];
            foreach (int id in row)
            {
                if (!MapDesign!.ImageMap.ContainsKey(id))
                {// Invalid tile id recieved from client
                    crud.InsertLogEvent(new LogEvent(DateTime.Now, LogLevel.Warning, "Invalid Tile id received from client"));
                    ShowError(DownloadErrMsg);        
                }
                imgRow.Add(MapDesign!.ImageMap[id]);
            }
            imagePathMatrix.Add(imgRow);
        }

        string tileImgDir = Directory.GetCurrentDirectory() + "\\wwwroot\\static\\Tiles\\";
        byte[] imgBytes = [];
        try
        {
            SKBitmap bitMap = JpegMerger.MergeFrom2DList(imagePathMatrix,
                                                         tileImgDir,
                                                         BASE_TILE_SIZE,
                                                         BASE_TILE_SIZE);
            using (var stream = new MemoryStream())
            {
                bitMap.Encode(stream, SKEncodedImageFormat.Png, 100);
                bitMap.Dispose();
                imgBytes = stream.ToArray();
            }
        }
        catch (Exception ex)
        {
            crud.InsertLogEvent(new LogEvent(DateTime.Now, LogLevel.Error, $"msg {ex.Message}\n{ex.StackTrace}"));
            ShowError(DownloadErrMsg);
        }
        return Task.FromResult(imgBytes);
    }

    private void ShowError(string errMsg)
    {
        NavManager.NavigateTo($"/Error/{errMsg}");
    }
}
